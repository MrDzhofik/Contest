// Вадим только недавно прошел собеседование в одну известную компанию на должность разработчика.
// В ходе собеседования он смог решить одну несложную алгоритмическую задачу: по множеству целых положительных различных
// чисел он научился строить представление этого множества через отсортированные интервалы (или срезы).
// Так, например, написанный им алгоритм по множеству чисел {1,5,2,3,11,9,4,6,8}{1,5,2,3,11,9,4,6,8} получает следующую
// строку наименьшего размера «1−6,8−9,111−6,8−9,11» (без пробелов), т.е. представляет исходное множество через интервалы
//  подряд идущих чисел, при этом сортируя в порядке возрастания указанные интервалы.
// Заметим, что решение Вадима не выдаст строку «1−5,6,8−9,111−5,6,8−9,11» и подобные.

// Вам предстоит обратная задача: по указанной строке восстановить множество чисел, из которого указанная строка была построена
// . Заметьте, что выводить множество нужно в отсортированном порядке.

// Формат входных данных

// В единственной строке дана строка — результат работы алгоритма Вадима.
//  Гарантируется, что исходное множество состояло только из различных целых положительных чисел,
// не превосходящих 109109, и количество этих чисел не превосходило 105105.

// Формат выходных данных

// В единственной строке выведите через пробел отсортированное множество чисел, из которого была получена указанная строка.

package main

import (
	"fmt"
	"sort"
	"strconv"
	"strings"
)

func main() {
	var input string
	fmt.Scan(&input)

	parts := strings.Split(input, ",")

	var result []int

	for _, part := range parts {
		if strings.Contains(part, "-") {
			bounds := strings.Split(part, "-")
			start, _ := strconv.Atoi(bounds[0])
			end, _ := strconv.Atoi(bounds[1])

			for i := start; i <= end; i++ {
				result = append(result, i)
			}
		} else {
			num, _ := strconv.Atoi(part)
			result = append(result, num)
		}
	}

	sort.Ints(result)

	for _, num := range result {
		fmt.Printf("%d ", num)
	}
}
